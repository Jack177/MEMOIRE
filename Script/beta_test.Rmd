---
title: "beta"
author: "Jordan"
date: "`r Sys.Date()`"
output: html_document
---

```{r}
library(ggplot2)
library(vegetarian)
library(vegan)
library(dplyr)
library(readxl)
library(iNEXT)
```

## SDD
https://wp.sciviews.org/sdd-umons2-2019/indices-de-biodiversite.html
```{r}
data(BCI)

#library(vegan)
#data("BCI")

set.seed(2003)
bci_sub <- sample_n(BCI, 5) 

# Exploration partielle des données (15 premières espèces)
skimr::skim(bci_sub[, 1:15])
```





```{r}
vegan::vegdist(bci_sub, method = "jaccard", binary = TRUE)
```

```{r}
zoo <- read_excel("D:/OneDrive - UMONS/UMONS/MA2/MEMOIRE/Statistique/R/STAT-MEMOIRE/RAW1/zoo.xlsx")
```

```{r}
zoo %>%
  select(., -class) %>% # Elimination de la colonne class
  scale(.) %>% # Standardisation des 19 colonnes
  as_tibble(.) %>% # Conversion de la matrice en data.frame +tibble
  slice(., 13:18) -> zoo6      # Récupération des lignes 13 à 18

zoo6 %>%
  vegan::vegdist(., method = "euclidean") -> zoo6std_dist

zoo6std_dist %>%
  hclust(.) -> zoo6std_clust # Calcul du dendrogramme
  plot(zoo6std_clust)
```
## Mes données

Importation des données.
```{r Import}
# Import
# Tour PC
setwd("D:/OneDrive - UMONS/UMONS/MA2/MEMOIRE/Statistique/R/STAT-MEMOIRE/RAW2")
# Laptop
#setwd("C:/Users/Jordan/OneDrive - UMONS/UMONS/MA2/MEMOIRE/Statistique/R/STAT-MEMOIRE/RAW2")

SpecCondStat <- read_excel("SpecCondStat.xls")


# Nom plus compact
SCS <- SpecCondStat

# Retirer le site de Condorcet
SCS <- filter(SCS, TOPO != "Condorcet" )

# Renommer plus simplement
rename(SCS, "sp" = "SPEC.TAXPRIO" ) -> SCS
rename(SCS, "sites" = "TOPO" ) -> SCS

# Retirer les observations contenant l'espèce : "XXX"
# SCS <- filter(SCS, SPEC.TAXPRIO != "Bombus (Bombus)  sp." )

# Remplacement des noms d'espèces désuets
SCS$sp[SCS$sp == "Bombus lucorum"] <- "Terrestribombus  sp."
SCS$sp[SCS$sp == "Bombus terrestris"] <- "Terrestribombus  sp."
SCS$sp[SCS$sp == "Chalicodoma ericetorum"] <- "Megachile ericetorum"
SCS$sp[SCS$sp == "Halictus tumulorum"] <- "Seladonia tumulorum"

# Remplacement du noms de sites
SCS$sites[SCS$sites == "Les Gourmandes de la Procession"] <- "Gourmandes de la Procession"

# Preparation des données 
data_bee_sp <- select(SCS, sp, N, sites)
data_bee_sp <- as.data.frame(data_bee_sp)
data_bee_sp <- aggregate(N ~ sp + sites, data = data_bee_sp, sum)
data_bee_sp <- xtabs(N ~ sites + sp, data_bee_sp)
data_bee_sp <- type.convert(data_bee_sp)

```
Je ne sais pas du tout quelle methode dans hclust() il faudrait utiliser (bray, upgma, single), ni si je ferai mieux de raréfier sur la couverture ou abondance sur mes données.

```{r}
# #data_bee_sp %>%
# bee.rare33 %>%
#   scale(.) %>% # Standardisation des 19 colonnes
#   as_tibble(.) -> data  # Conversion de la matrice en data.frame +tibble     
# 
# data %>%
#   vegan::vegdist(data, method = "bray") -> data_dist
# 
# data_dist %>%
#   hclust(., method = "complete") -> data_clust # Calcul du dendrogramme
#   plot(data_clust)
#   
  
# ggdendro::ggdendrogram(zoo6std_clust)
```


## David Zeleny
https://www.davidzeleny.net/anadat-r/doku.php/en:hier-agglom_examples

La méthode de Ward ne doit pas être combiné avec des mesures de distance qui ne sont pas strictement métriques, comme par exemple la distance de Bray-Curtis.
```{r}
vltava.spe <- read.delim ('https://raw.githubusercontent.com/zdealveindy/anadat-r/master/data/vltava-spe.txt', row.names = 1)
#library (vegan)
dis <- vegdist (sqrt (vltava.spe), method = 'bray') # percentage cover data are transformed by square root
cluster.single <- hclust (d = dis, method = 'single')
cluster.complete <- hclust (dis, 'complete')
cluster.average <- hclust (dis, 'average')
par (mfrow = c (1,3)) # will draw all dendrograms into one figure
 
plot (cluster.single, main = 'Single linkage')
plot (cluster.complete, main = 'Complete linkage')
plot (cluster.average, main = 'Average linkage')
```


```{r}
library (cluster)
cluster.flexible <- agnes (x = dis, method = 'flexible', par.method = 0.625)
cluster.flexible.hclust <- as.hclust (cluster.flexible)
plot (cluster.flexible.hclust)
```
```{r}
data (BCI)  # example using Barro Colorado data
BCI.log <- log1p (BCI)  # first, log transform species data
bc.dist <- vegdist (BCI.log, method = 'bray')
bc.dist
clust <- agnes (sqrt (bc.dist), method = 'ward') # calculate Ward's algorithm 
# on square-rooted Bray-Curtis distance
#plot (clust, which.plot = 2)
# Change juste le titre
clust.hclust <- as.hclust (clust)
plot (clust.hclust)
# Regrouper en cluster
groups <- cutree (clust, k = 5)
groups
group.order <- groups[clust.hclust$order]
group.order
group.in.cluster <- unique (group.order)
group.in.cluster

plot (clust.hclust)
rect.hclust (clust.hclust, border = group.in.cluster, k = 5) 
legend ('topleft', legend = paste ('Cluster', 1:5), pch = 22, col = 1:5, bty = 'n')
```

```{r}
# First, NMDS with Bray-Curtis distances
NMDS <- metaMDS (vegdist (BCI.log))  # note that I could use also "NMDS <- metaMDS (bc.dist)" here
par (mfrow = c(1,2)) # I want to plot both plots into one figure, with two panels in one row
ordiplot (NMDS, type = 'n')
points (NMDS, pch = groups, col = groups)
legend ('topright', pch = 1:5, col = 1:5, legend = 1:5, bty = 'n')
 
# Second, DCA ordination (implicitly using chi-square distance)
DCA <- decorana (BCI.log)
ordiplot (DCA, type = 'n', display = 'si')
points (DCA, pch = groups, col = groups)
legend ('topright', pch = 1:5, col = 1:5, legend = 1:5, bty = 'n')
```




### Mes données non raréfiées
```{r}
dis <- vegdist(sqrt (data_bee_sp), method = 'bray') # percentage cover data are transformed by square root
cluster.single <- hclust (d = dis, method = 'single')
cluster.complete <- hclust (dis, 'complete')
cluster.average <- hclust (dis, 'average')

par (mfrow = c (1,3)) # will draw all dendrograms into one figure
 
plot (cluster.single, main = 'Single linkage')
plot (cluster.complete, main = 'Complete linkage')
plot (cluster.average, main = 'Average linkage')
```

```{r}

data_bee_sp.log <- log1p (data_bee_sp)  # first, log transform species data
bc.dist <- vegdist (data_bee_sp.log, method = 'bray', scale= TRUE) # Scale sert à standardiser si on a des unités différentes, ici ce n'est pas le cas et cela ne change rien
bc.dist
print (bc.dist, diag = TRUE)
clust <- agnes (sqrt (bc.dist), method = 'ward') # calculate Ward's algorithm 
# on square-rooted Bray-Curtis distance
#plot (clust, which.plot = 2)
# Change juste le titre
clust.hclust <- as.hclust (clust)
plot (clust.hclust)
# Regrouper en cluster
groups <- cutree (clust, k = 2)
groups
group.order <- groups[clust.hclust$order]
group.order
group.in.cluster <- unique (group.order)
group.in.cluster

plot (clust.hclust)
rect.hclust (clust.hclust, border = group.in.cluster, k = 2) 
legend ('topleft', legend = paste ('Cluster', 1:2), pch = 22, col = 1:5, bty = 'n')
```
```{r}
# First, NMDS with Bray-Curtis distances
NMDS <- metaMDS (vegdist (data_bee_sp.log))  # note that I could use also "NMDS <- metaMDS (bc.dist)" here
par (mfrow = c(1,2)) # I want to plot both plots into one figure, with two panels in one row
ordiplot (NMDS, type = 'n')
points (NMDS, pch = groups, col = groups)
legend ('topright', pch = 1:2, col = 1:2, legend = 1:2, bty = 'n')
 
# Second, DCA ordination (implicitly using chi-square distance)
DCA <- decorana (data_bee_sp.log)
ordiplot (DCA, type = 'n', display = 'si')
points (DCA, pch = groups, col = groups)
legend ('topright', pch = 1:2, col = 1:2, legend = 1:2, bty = 'n')
```

### Mes données raréfiés sur base de la couverture
```{r}
# raréfaction sur base de la couverture
#hill <- estimateD(t(data_bee_sp), base="coverage")

# Raréfaction à 33 individus (Parc Bonaert a le plus petit nbr d'individus)
bee.rare33 <- rarefy(bee, sample = 33)

dis <- vegdist(sqrt (bee.rare33), method = 'bray') # percentage cover data are transformed by square root
cluster.single <- hclust (d = dis, method = 'single')
cluster.complete <- hclust (dis, 'complete')
cluster.average <- hclust (dis, 'average')

par (mfrow = c (1,3)) # will draw all dendrograms into one figure
 
plot (cluster.single, main = 'Single linkage')
plot (cluster.complete, main = 'Complete linkage')
plot (cluster.average, main = 'Average linkage')
```




## package vegan
https://cran.r-project.org/web/packages/vegan/vignettes/diversity-vegan.pdf

```{r}
beta <- vegdist(BCI, binary=TRUE)
mean(beta)
```





## Dan Knights
https://www.youtube.com/watch?v=lcbp6EecDg4
```{r}
d_bray <- vegdist(data_bee_sp)
pc_bray <-  cmdscale(d_bray, k = 2)
plot(pc_bray[,1], pc_bray[,2], cex= 3, pch=16)
```
Heatmap
```{r}
heatmap(as.matrix(d_bray))
# scale: a character indicating if the values should be centered and scaled in either the row direction or the column direction, or none. Allowed values are in c(“row”, “column”, “none”). Default is “row”.
```

Pour obtenir l'association d'un site avec lui-même on utilise diag = TRUE, la diagonal est de 0 ce qui signifie que la dissimilarité est de 0, on a donc une matrice de dissimilarité et pas de similarité !
Bray-curtis s'étale de 0 à 1, tandis que le chi² part de 0 mais n'a pas de limite supérieur.
9.2.1.1
https://essicolo.github.io/ecologie-mathematique-R/chapitre-ordination.html
```{r}
# Matrice de distance pour calculer la diversité Beta
dis <- vegdist(sqrt (data_bee_sp), method = 'bray', diag =TRUE) # percentage cover data are transformed by square root
cluster.single <- hclust (d = dis, method = 'single')
cluster.complete <- hclust (dis, 'complete')
cluster.average <- hclust (dis, 'average')
heatmap(as.matrix(dis))
```

```{r}
library("pheatmap")
dis <- vegdist(sqrt (data_bee_sp), method = 'bray', diag =TRUE)
D_chisq_R <- as.matrix(dis )
pheatmap(D_chisq_R, display_numbers = round(D_chisq_R, 2))
# exporter en 8x8
```

```{r}
occurence <- as.data.frame(data_bee_sp) %>%
  transmute_all(~if_else(. > 0, 1, 0))
occurence_r <- (occurence)
D_jacc_R <- as.matrix(vegdist(occurence_r, method = "jaccard"))
pheatmap(D_jacc_R, display_numbers = round(D_jacc_R, 2))
```


```{r}
vare.dist <- vegdist(data_bee_sp)

#vare.hc <- cluster.average (hclust average)
vare.hc <- hclust(as.dist(vare.dist))

# melt library(reshape2)
vare.dist.long <- vare.dist %>% as.matrix %>% melt %>%
mutate(Var1 = factor(Var1, levels = unique(vare.hc$labels)[vare.hc$order]))%>%
mutate(Var2 = factor(Var2, levels = unique(vare.hc$labels)[vare.hc$order]))

vare.dist %>% as.matrix %>% .[vare.hc$order, vare.hc$order] %>% melt %>%
ggplot(aes(x = Var1, y = Var2, fill = value)) + geom_tile() + scale_fill_viridis(direction = 1) +
theme(axis.text.x = element_text(angle = 270, hjust = 0, vjust = 0.5
                                ))
```

```{r}
ggplot(d_bray, aes(x = Labels, y = Size, fill = Size)) +
  labs(title = "Abondance des abeilles sauvages", x = '', y = '') + # Titre et titre axe
  geom_tile(color = "black") +
  coord_fixed() +
  guides(fill = guide_colourbar(label = FALSE,
                                ticks = FALSE)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0, size = 3, hjust = 0),
        axis.text.y = element_text(size = 3, hjust = 0,  vjust = 0.4),
        legend.position = "left", # position légende
        legend.title = element_text(size = 6), # Taille titre légende texte 
        legend.text = element_text(size = 6), # Taille légende échelle texte 
        plot.title = element_text(size = 8, hjust = 0.5), # Taille titre texte 
        legend.key.size = unit(1.5, "cm"),
        legend.key.width = unit(.65,"cm")) + 
  scale_y_discrete(position = "right") + # y label à droite
  guides(fill = guide_colourbar(title = "Abondance")) + # Titre légende
  #scale_fill_distiller(palette = "Reds", direction = +1)  # couleur
  #scale_fill_distiller(palette = "YlOrBr", direction = 1, na.value = "grey50")
  scale_fill_viridis(option = "B", direction = -1, na.value = "white")  # couleur
```




## Legendre 2012



```{r}
# On importe un jeu de donn?es test : les poissons de la rivi?re Doubs
library(ade4)
data (doubs)
spe <- doubs$fish# Une rivi?re, 30 sites, une longue liste de poissons
env <- doubs$env # La m?me rivi?re, les m?mes sites, mais de nombreux types de descripteurs environnementaux
?doubs #Plus d'infos
# On retire le site ! car il est vide !
spe = spe[-8,]
env = env[-8,]
```

```{r}
#Multiplicative partitioning of Hill numbers (Jost 2006, 2007)
?d
# Mean alpha species richness
d(spe, lev = "alpha", q = 0)
# Mean alpha Shannon diversity
d(spe, lev = "alpha", q = 1)
# Mean alpha Simpson diversity
d(spe, lev = "alpha", q = 2, boot = TRUE)
# Multiplicative beta species richness
d(spe, lev = "beta", q = 0)
# Multiplicative beta Shannon diversity
d(spe, lev = "beta", q = 1)
# Multiplicative beta Simpson diversity
d(spe, lev = "beta", q = 2, boot = TRUE)
# Gamma species richness
d(spe, lev = "gamma", q = 0)
# Gamma Shannon diversity
d(spe, lev = "gamma", q = 1)
# Gamma Simpson diversity
d(spe, lev = "gamma", q = 2, boot = TRUE)

# Plot multiplicative beta diversity vs order
mbeta <- data.frame(order = 0:20, beta = NA, se = NA)
for (i in 1:nrow(mbeta)) {
out <- d(spe, lev = "beta", q = mbeta$order[i], boot = TRUE)
mbeta$beta[i] <- out$D.Value
mbeta$se[i] <- out$StdErr
}
mbeta
ggplot(mbeta, aes(order, beta)) +
geom_point() +
geom_line() +
geom_errorbar(aes(order, beta, ymin = beta - se,
ymax = beta + se), width = 0.2) +
labs(y = "Multiplicative beta diversity",
x = "Order of the diversity measure")
```
```{r}
## Q-mode dissimilarity and distance measures for
## (semi-)quantitative data
# Percentage difference (aka Bray-Curtis) dissimilarity matrix
# on raw species data
spe.db <- vegdist(spe) # method = "bray" (default)
head(spe.db)
# Percentage difference (aka Bray-Curtis) dissimilarity matrix
# on log-transformed abundances
spe.dbln <- vegdist(log1p(spe))
head(spe.dbln)
# Chord distance matrix
spe.dc <- dist.ldc(spe, "chord")
# Alternate, two-step computation in vegan:
spe.norm <- decostand(spe, "nor")
spe.dc <- dist(spe.norm)
head(spe.dc)
# Hellinger distance matrix
spe.dh <- dist.ldc(spe) # Hellinger is the default distance
# Alternate, two-step computation in vegan:
spe.hel <- decostand(spe, "hel")
spe.dh <- dist(spe.hel)
head(spe.dh)
# Log-chord distance matrix
spe.logchord <- dist.ldc(spe, "log.chord")
# Alternate, three-step computation in vegan:
spe.ln <- log1p(spe)
spe.ln.norm <- decostand(spe.ln, "nor")
spe.logchord <- dist(spe.ln.norm)
head(spe.logchord)
```





